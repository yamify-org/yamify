---
title: Deployment Overview - Yamify
---

# Deployment

This guide provides comprehensive instructions for deploying Yamify applications to various production environments. Following these deployment strategies will ensure your application is reliable, scalable, and secure in production.

## Deployment Strategies

Yamify applications can be deployed using various strategies, depending on your requirements, budget, and infrastructure preferences:

### Static Site Generation (SSG)

For content-focused sites with minimal dynamic functionality, SSG provides excellent performance and security:

```bash
# Build for static export
npm run build

# The output in the 'out' directory can be deployed to any static hosting service
```

### Server-Side Rendering (SSR)

For applications requiring dynamic rendering or authentication:

```bash
# Build for production
npm run build

# Start the production server
npm start
```

### Incremental Static Regeneration (ISR)

For applications with content that changes periodically but not constantly:

```tsx
// pages/projects/[id].tsx
export async function getStaticProps({ params }) {
  const { id } = params;
  const project = await fetchProject(id);
  
  return {
    props: { project },
    // Revalidate at most once every hour
    revalidate: 3600,
  };
}

export async function getStaticPaths() {
  const projects = await fetchPopularProjects();
  
  return {
    paths: projects.map(project => ({ params: { id: project.id } })),
    // Generate additional pages on-demand
    fallback: 'blocking',
  };
}
```

## Environment Configuration

### Environment Variables

Manage environment-specific configuration with environment variables:

#### Local Development

Create a `.env.local` file for local development:

```
NEXT_PUBLIC_API_URL=http://localhost:3001/api
NEXT_PUBLIC_SITE_URL=http://localhost:3000
AUTH_SECRET=your-development-secret
```

#### Production Environment

Set environment variables in your hosting platform's configuration:

```
NEXT_PUBLIC_API_URL=https://api.yourdomain.com
NEXT_PUBLIC_SITE_URL=https://yourdomain.com
AUTH_SECRET=your-production-secret
NODE_ENV=production
```

### Schema Validation

Validate environment variables at build time:

```typescript
// env.ts
import { z } from 'zod';

const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  NODE_ENV: z.enum(['development', 'test', 'production']),
  NEXT_PUBLIC_API_URL: z.string().url(),
  AUTH_SECRET: z.string().min(32),
});

function validateEnv() {
  const parsed = envSchema.safeParse(process.env);
  
  if (!parsed.success) {
    console.error('u274c Invalid environment variables:', parsed.error.flatten().fieldErrors);
    throw new Error('Invalid environment variables');
  }
}

// Validate in non-production only to avoid crashing production builds
if (process.env.NODE_ENV !== 'production') {
  validateEnv();
}

export {};
```

## CI/CD Pipeline

### GitHub Actions

Implement a CI/CD pipeline with GitHub Actions:

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Lint
        run: npm run lint
      
      - name: Type check
        run: npm run type-check
      
      - name: Test
        run: npm test
      
      - name: Build
        run: npm run build
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}
          NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL }}
      
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
```

## Cloud Providers

Yamify applications can be deployed to various cloud providers:

### Vercel

Vercel is the recommended deployment platform for Yamify applications:

1. **Install Vercel CLI**:

```bash
npm install -g vercel
```

2. **Deploy**:

```bash
vercel --prod
```

3. **Configure Environment Variables**:
   - Go to your project settings in the Vercel dashboard
   - Add environment variables under "Environment Variables" section

### Netlify

1. **Install Netlify CLI**:

```bash
npm install -g netlify-cli
```

2. **Create a `netlify.toml` configuration**:

```toml
[build]
  command = "npm run build"
  publish = "out"

[build.environment]
  NEXT_TELEMETRY_DISABLED = "1"

[[plugins]]
  package = "@netlify/plugin-nextjs"
```

3. **Deploy**:

```bash
netlify deploy --prod
```

### AWS Amplify

1. **Create an Amplify configuration**:

```yaml
# amplify.yml
version: 1
frontend:
  phases:
    preBuild:
      commands:
        - npm ci
    build:
      commands:
        - npm run build
  artifacts:
    baseDirectory: .next
    files:
      - '**/*'
  cache:
    paths:
      - node_modules/**/*
```

2. **Deploy using Amplify Console**:
   - Connect your GitHub repository to AWS Amplify
   - Follow the prompts to configure your build settings
   - Add environment variables in the Amplify Console

## Docker Deployment

Yamify applications can be containerized for deployment to any platform supporting Docker:

### Dockerfile

```dockerfile
# Dockerfile
FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
WORKDIR /app

# Install dependencies based on the preferred package manager
COPY package.json package-lock.json* ./
RUN npm ci

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

ENV NEXT_TELEMETRY_DISABLED 1

RUN npm run build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

# Set the correct permission for prerender cache
RUN mkdir .next
RUN chown nextjs:nodejs .next

# Automatically leverage output traces to reduce image size
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME 0.0.0.0

CMD ["node", "server.js"]
```

### Building and Running Docker Container

```bash
# Build the Docker image
docker build -t yamify-app .

# Run the container
docker run -p 3000:3000 -e DATABASE_URL=your-db-url -e AUTH_SECRET=your-secret yamify-app
```

## Database Deployment

### PostgreSQL

For Yamify applications using PostgreSQL:

1. **Managed Service** (Recommended):
   - Use a service like AWS RDS, Google Cloud SQL, or [Neon](https://neon.tech/)
   - Configure connection pooling for optimal performance

2. **Connection String**:
   - Store the connection string as an environment variable:
   ```
   DATABASE_URL=postgresql://user:password@host:port/database
   ```

3. **Migrations**:
   - Run migrations during deployment:
   ```bash
   npx prisma migrate deploy
   ```

## Performance Optimization

### Content Delivery Network (CDN)

Use a CDN to serve static assets:

1. **Vercel Edge Network**:
   - Automatically included with Vercel deployments

2. **Cloudflare**:
   - Point your domain to Cloudflare DNS
   - Enable CDN features

### Caching Strategies

Implement effective caching:

```typescript
// Middleware to add caching headers
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const response = NextResponse.next();
  
  // Cache static assets for 1 year
  if (request.nextUrl.pathname.startsWith('/_next/static')) {
    response.headers.set('Cache-Control', 'public, max-age=31536000, immutable');
  }
  
  // Cache images for 1 week
  if (request.nextUrl.pathname.startsWith('/images')) {
    response.headers.set('Cache-Control', 'public, max-age=604800');
  }
  
  return response;
}

export const config = {
  matcher: ['/_next/static/:path*', '/images/:path*'],
};
```

## Security Considerations

### Headers

Configure security headers:

```typescript
// next.config.js
const securityHeaders = [
  {
    key: 'X-DNS-Prefetch-Control',
    value: 'on',
  },
  {
    key: 'Strict-Transport-Security',
    value: 'max-age=63072000; includeSubDomains; preload',
  },
  {
    key: 'X-XSS-Protection',
    value: '1; mode=block',
  },
  {
    key: 'X-Frame-Options',
    value: 'SAMEORIGIN',
  },
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff',
  },
  {
    key: 'Referrer-Policy',
    value: 'strict-origin-when-cross-origin',
  },
  {
    key: 'Content-Security-Policy',
    value: "default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:;",
  },
];

module.exports = {
  // ... other config
  async headers() {
    return [
      {
        source: '/:path*',
        headers: securityHeaders,
      },
    ];
  },
};
```

### Rate Limiting

Implement rate limiting for API routes:

```typescript
// app/api/route.ts
import { NextResponse } from 'next/server';
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

// Create a new ratelimiter
const redis = new Redis({
  url: process.env.UPSTASH_REDIS_URL || '',
  token: process.env.UPSTASH_REDIS_TOKEN || '',
});

const ratelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '10 s'),
});

export async function GET(request: Request) {
  const ip = request.headers.get('x-forwarded-for') || 'anonymous';
  const { success, limit, reset, remaining } = await ratelimit.limit(ip);
  
  if (!success) {
    return new NextResponse('Too Many Requests', {
      status: 429,
      headers: {
        'X-RateLimit-Limit': limit.toString(),
        'X-RateLimit-Remaining': remaining.toString(),
        'X-RateLimit-Reset': reset.toString(),
      },
    });
  }
  
  // Your API logic here
  return NextResponse.json({ message: 'Hello World' });
}
```

## Monitoring and Analytics

### Application Monitoring

Implement monitoring to track application performance and errors:

1. **Vercel Analytics**:
   - Enable in Vercel dashboard
   - Provides Web Vitals metrics

2. **Sentry**:
   - Install Sentry SDK:
   ```bash
   npm install @sentry/nextjs
   ```
   - Configure in `next.config.js`:
   ```js
   // next.config.js
   const { withSentryConfig } = require('@sentry/nextjs');
   
   const nextConfig = {
     // Your Next.js config
   };
   
   module.exports = withSentryConfig(
     nextConfig,
     { silent: true }
   );
   ```

### Logging

Implement structured logging:

```typescript
// lib/logger.ts
type LogLevel = 'debug' | 'info' | 'warn' | 'error';

function formatLog(level: LogLevel, message: string, meta: Record<string, any> = {}) {
  return JSON.stringify({
    timestamp: new Date().toISOString(),
    level,
    message,
    ...meta,
  });
}

export const logger = {
  debug(message: string, meta?: Record<string, any>) {
    if (process.env.NODE_ENV !== 'production') {
      console.debug(formatLog('debug', message, meta));
    }
  },
  
  info(message: string, meta?: Record<string, any>) {
    console.info(formatLog('info', message, meta));
  },
  
  warn(message: string, meta?: Record<string, any>) {
    console.warn(formatLog('warn', message, meta));
  },
  
  error(message: string, error?: Error, meta?: Record<string, any>) {
    console.error(
      formatLog('error', message, {
        ...meta,
        error: error ? { message: error.message, stack: error.stack } : undefined,
      })
    );
  },
};
```

## Load Testing

Perform load testing before deploying to production:

```bash
# Install k6 load testing tool
brew install k6

# Create a load test script
cat > load-test.js << 'EOF'
import http from 'k6/http';
import { sleep, check } from 'k6';

export const options = {
  vus: 100, // Virtual users
  duration: '30s',
};

export default function () {
  const res = http.get('https://your-staging-url.com');
  check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
  sleep(1);
}
EOF

# Run the load test
k6 run load-test.js
```

## Scaling Strategies

### Horizontal Scaling

Scale your application by adding more instances:

1. **Vercel**:
   - Automatic scaling based on traffic

2. **Kubernetes**:
   - Deploy with a Horizontal Pod Autoscaler:
   ```yaml
   apiVersion: autoscaling/v2
   kind: HorizontalPodAutoscaler
   metadata:
     name: yamify-app-hpa
   spec:
     scaleTargetRef:
       apiVersion: apps/v1
       kind: Deployment
       name: yamify-app
     minReplicas: 2
     maxReplicas: 10
     metrics:
     - type: Resource
       resource:
         name: cpu
         target:
           type: Utilization
           averageUtilization: 70
   ```

## Conclusion

By following these deployment practices, you can ensure your Yamify application is reliable, performant, and secure in production. Remember to test thoroughly in a staging environment before deploying to production.

## Related Resources

- [Environment Variables Reference](/deployment/environment-variables)
- [Database Configuration](/deployment/database-setup)
- [Authentication in Production](/api-docs/authentication#production-considerations)
- [Performance Optimization](/development/performance)
