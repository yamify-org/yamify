---
title: Design Patterns - Yamify
---

# Design Patterns

This guide outlines recommended design patterns and architectural approaches for building applications with Yamify. Following these patterns will help ensure your application is maintainable, scalable, and follows best practices.

## Application Architecture

### Feature-Based Structure

Organize your codebase by features rather than technical concerns. This approach improves maintainability as your application grows.

```
src/
├─ features/
│  ├─ authentication/
│  │  ├─ components/
│  │  ├─ hooks/
│  │  ├─ services/
│  │  └─ types/
│  ├─ projects/
│  │  ├─ components/
│  │  ├─ hooks/
│  │  ├─ services/
│  │  └─ types/
│  └─ dashboard/
│     ├─ components/
│     ├─ hooks/
│     └─ services/
├─ shared/
│  ├─ components/
│  ├─ hooks/
│  ├─ utils/
│  └─ types/
└─ app/
   ├─ layout.tsx
   ├─ page.tsx
   └─ ...
```

### Domain-Driven Design

When appropriate, apply Domain-Driven Design principles to model complex business domains:

```typescript
// Domain entity with business logic
class Project {
  private id: string;
  private name: string;
  private tasks: Task[];
  private status: ProjectStatus;
  private collaborators: User[];
  
  constructor(props: ProjectProps) {
    this.id = props.id;
    this.name = props.name;
    this.tasks = props.tasks || [];
    this.status = props.status || ProjectStatus.ACTIVE;
    this.collaborators = props.collaborators || [];
  }
  
  // Business logic methods
  public addTask(task: Task): void {
    // Validation logic
    if (this.status === ProjectStatus.ARCHIVED) {
      throw new Error('Cannot add tasks to archived projects');
    }
    
    this.tasks.push(task);
  }
  
  public archive(): void {
    if (this.hasIncompleteTask()) {
      throw new Error('Cannot archive project with incomplete tasks');
    }
    
    this.status = ProjectStatus.ARCHIVED;
  }
  
  private hasIncompleteTask(): boolean {
    return this.tasks.some(task => !task.isComplete());
  }
  
  // Other methods...
}
```

## Component Patterns

### Compound Components

Use compound components for complex UI elements that have multiple related parts:

```tsx
// Form.tsx - Main component with sub-components
const FormContext = React.createContext<FormContextType | undefined>(undefined);

function Form({ children, onSubmit, ...props }) {
  const [values, setValues] = useState({});
  
  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit(values);
  };
  
  const updateField = (name, value) => {
    setValues({ ...values, [name]: value });
  };
  
  return (
    <FormContext.Provider value={{ values, updateField }}>
      <form onSubmit={handleSubmit} {...props}>
        {children}
      </form>
    </FormContext.Provider>
  );
}

// Field sub-component
Form.Field = function FormField({ name, label, ...props }) {
  const { values, updateField } = useContext(FormContext);
  
  return (
    <div className="form-field">
      <label htmlFor={name}>{label}</label>
      <input
        id={name}
        name={name}
        value={values[name] || ''}
        onChange={(e) => updateField(name, e.target.value)}
        {...props}
      />
    </div>
  );
};

// Usage
<Form onSubmit={handleSubmit}>
  <Form.Field name="name" label="Name" required />
  <Form.Field name="email" label="Email" type="email" required />
  <button type="submit">Submit</button>
</Form>
```

### Component Composition

Prefer composition over props for complex components:

```tsx
// Instead of this:
<DashboardCard 
  title="Project Stats" 
  icon={<ChartIcon />}
  footer={<Button>View Details</Button>}
  loading={isLoading}
>
  <Stats data={data} />
</DashboardCard>

// Prefer this:
<Card>
  <Card.Header>
    <Card.Title>Project Stats</Card.Title>
    <Card.Icon><ChartIcon /></Card.Icon>
  </Card.Header>
  <Card.Body>
    {isLoading ? <Skeleton /> : <Stats data={data} />}
  </Card.Body>
  <Card.Footer>
    <Button>View Details</Button>
  </Card.Footer>
</Card>
```

### Container/Presenter Pattern

Separate data fetching logic from presentation:

```tsx
// ProjectsContainer.tsx - Handles data fetching and state
'use client';

import { useState, useEffect } from 'react';
import { ProjectsList } from './ProjectsList';
import { fetchProjects } from '@/services/api';

export function ProjectsContainer() {
  const [projects, setProjects] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function loadData() {
      try {
        setLoading(true);
        const data = await fetchProjects();
        setProjects(data);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    }
    
    loadData();
  }, []);
  
  return (
    <ProjectsList 
      projects={projects}
      loading={loading}
      error={error}
    />
  );
}

// ProjectsList.tsx - Pure presentation component
export function ProjectsList({ projects, loading, error }) {
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return (
    <div className="grid grid-cols-3 gap-4">
      {projects.map(project => (
        <ProjectCard key={project.id} project={project} />
      ))}
    </div>
  );
}
```

## State Management Patterns

### State Categorization

Categorize state based on its scope and persistence requirements:

1. **Local UI State**: Component-specific using `useState`
2. **Shared State**: Application-wide using Context API or state management libraries
3. **Server State**: Data from API using data fetching hooks
4. **URL State**: State persisted in the URL using query parameters
5. **Form State**: Input values and validation using form libraries

### Custom Hooks for Complex State

```tsx
// useTaskManagement.ts
import { useState, useCallback } from 'react';
import { Task, TaskStatus } from '@/types';
import { createTask, updateTask, deleteTask } from '@/services/taskService';

export function useTaskManagement(initialTasks = []) {
  const [tasks, setTasks] = useState(initialTasks);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  const addTask = useCallback(async (taskData) => {
    setLoading(true);
    setError(null);
    
    try {
      const newTask = await createTask(taskData);
      setTasks(prev => [...prev, newTask]);
      return newTask;
    } catch (err) {
      setError(err);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);
  
  const updateTaskStatus = useCallback(async (taskId, status) => {
    setLoading(true);
    setError(null);
    
    try {
      const updatedTask = await updateTask(taskId, { status });
      setTasks(prev => 
        prev.map(task => task.id === taskId ? updatedTask : task)
      );
      return updatedTask;
    } catch (err) {
      setError(err);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);
  
  const removeTask = useCallback(async (taskId) => {
    setLoading(true);
    setError(null);
    
    try {
      await deleteTask(taskId);
      setTasks(prev => prev.filter(task => task.id !== taskId));
    } catch (err) {
      setError(err);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);
  
  return {
    tasks,
    loading,
    error,
    addTask,
    updateTaskStatus,
    removeTask
  };
}
```

## API Integration Patterns

### API Layer Abstraction

Create a dedicated API layer to isolate backend communication:

```typescript
// api/client.ts - Base API client
import { getAccessToken, refreshToken } from '@/services/auth';

const BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'https://api.yamify.com/v1';

async function request(endpoint, options = {}) {
  const url = `${BASE_URL}${endpoint}`;
  
  // Default options
  const defaultOptions = {
    headers: {
      'Content-Type': 'application/json',
    },
  };
  
  // Merge options
  const fetchOptions = {
    ...defaultOptions,
    ...options,
    headers: {
      ...defaultOptions.headers,
      ...options.headers,
    },
  };
  
  // Add auth token if available
  const token = getAccessToken();
  if (token) {
    fetchOptions.headers.Authorization = `Bearer ${token}`;
  }
  
  try {
    const response = await fetch(url, fetchOptions);
    
    // Handle token expiration
    if (response.status === 401) {
      const refreshed = await refreshToken();
      if (refreshed) {
        // Retry with new token
        fetchOptions.headers.Authorization = `Bearer ${getAccessToken()}`;
        return fetch(url, fetchOptions);
      }
    }
    
    // Parse response
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.message || 'API request failed');
    }
    
    return data;
  } catch (error) {
    console.error('API request error:', error);
    throw error;
  }
}

// Export convenience methods
export const api = {
  get: (endpoint, options = {}) => 
    request(endpoint, { ...options, method: 'GET' }),
    
  post: (endpoint, data, options = {}) => 
    request(endpoint, { 
      ...options, 
      method: 'POST',
      body: JSON.stringify(data),
    }),
    
  put: (endpoint, data, options = {}) => 
    request(endpoint, { 
      ...options, 
      method: 'PUT',
      body: JSON.stringify(data),
    }),
    
  patch: (endpoint, data, options = {}) => 
    request(endpoint, { 
      ...options, 
      method: 'PATCH',
      body: JSON.stringify(data),
    }),
    
  delete: (endpoint, options = {}) => 
    request(endpoint, { ...options, method: 'DELETE' }),
};
```

### Service Layer

Create domain-specific services that use the API client:

```typescript
// services/projectService.ts
import { api } from '@/api/client';
import { Project, CreateProjectInput, UpdateProjectInput } from '@/types';

export async function getProjects(filters = {}) {
  const queryParams = new URLSearchParams(filters).toString();
  const endpoint = `/projects${queryParams ? `?${queryParams}` : ''}`;
  
  const response = await api.get(endpoint);
  return response.data.projects;
}

export async function getProjectById(id) {
  const response = await api.get(`/projects/${id}`);
  return response.data.project;
}

export async function createProject(projectData: CreateProjectInput) {
  const response = await api.post('/projects', projectData);
  return response.data.project;
}

export async function updateProject(id, projectData: UpdateProjectInput) {
  const response = await api.patch(`/projects/${id}`, projectData);
  return response.data.project;
}

export async function deleteProject(id) {
  await api.delete(`/projects/${id}`);
  return true;
}
```

## Error Handling Patterns

### Centralized Error Handling

Implement a centralized error handling system:

```typescript
// errors/errorHandler.ts
import { toast } from '@yamify/ui';

// Error types
export enum ErrorType {
  NETWORK = 'network',
  AUTHENTICATION = 'authentication',
  AUTHORIZATION = 'authorization',
  VALIDATION = 'validation',
  NOT_FOUND = 'not_found',
  SERVER = 'server',
  UNKNOWN = 'unknown',
}

// Map HTTP status codes to error types
const statusToErrorType = {
  400: ErrorType.VALIDATION,
  401: ErrorType.AUTHENTICATION,
  403: ErrorType.AUTHORIZATION,
  404: ErrorType.NOT_FOUND,
  500: ErrorType.SERVER,
};

// Determine error type from various error sources
export function getErrorType(error) {
  // Network errors
  if (!navigator.onLine || error.message === 'Network request failed') {
    return ErrorType.NETWORK;
  }
  
  // API errors with status code
  if (error.status) {
    return statusToErrorType[error.status] || ErrorType.UNKNOWN;
  }
  
  // Check for specific error messages
  if (error.message?.includes('authentication') || 
      error.message?.includes('login')) {
    return ErrorType.AUTHENTICATION;
  }
  
  return ErrorType.UNKNOWN;
}

// Handle errors based on their type
export function handleError(error, options = {}) {
  const errorType = getErrorType(error);
  const { silent = false, redirect = true } = options;
  
  // Log all errors
  console.error('Error:', error, 'Type:', errorType);
  
  // Handle based on type
  switch (errorType) {
    case ErrorType.NETWORK:
      if (!silent) {
        toast({
          title: 'Network Error',
          description: 'Please check your internet connection and try again.',
          status: 'error',
        });
      }
      break;
      
    case ErrorType.AUTHENTICATION:
      if (!silent) {
        toast({
          title: 'Authentication Error',
          description: 'Please log in again to continue.',
          status: 'error',
        });
      }
      
      if (redirect) {
        // Redirect to login
        window.location.href = '/login';
      }
      break;
      
    case ErrorType.AUTHORIZATION:
      if (!silent) {
        toast({
          title: 'Access Denied',
          description: 'You do not have permission to perform this action.',
          status: 'error',
        });
      }
      break;
      
    case ErrorType.VALIDATION:
      if (!silent) {
        toast({
          title: 'Validation Error',
          description: error.message || 'Please check your input and try again.',
          status: 'error',
        });
      }
      break;
      
    case ErrorType.NOT_FOUND:
      if (!silent) {
        toast({
          title: 'Not Found',
          description: 'The requested resource could not be found.',
          status: 'error',
        });
      }
      break;
      
    case ErrorType.SERVER:
      if (!silent) {
        toast({
          title: 'Server Error',
          description: 'Something went wrong on our end. Please try again later.',
          status: 'error',
        });
      }
      break;
      
    default:
      if (!silent) {
        toast({
          title: 'Error',
          description: error.message || 'An unexpected error occurred.',
          status: 'error',
        });
      }
  }
  
  // Could also report to error monitoring service here
  // reportToErrorMonitoring(error, errorType);
  
  return errorType;
}
```

## Performance Patterns

### Component Memoization

Use memoization to prevent unnecessary re-renders:

```tsx
import { memo, useMemo, useCallback } from 'react';

// Memoize a component
const ProjectItem = memo(function ProjectItem({ project, onEdit, onDelete }) {
  console.log('ProjectItem render', project.id);
  
  // Memoize event handlers
  const handleEdit = useCallback(() => {
    onEdit(project.id);
  }, [project.id, onEdit]);
  
  const handleDelete = useCallback(() => {
    onDelete(project.id);
  }, [project.id, onDelete]);
  
  // Memoize computed values
  const statusColor = useMemo(() => {
    switch (project.status) {
      case 'active': return 'green';
      case 'archived': return 'gray';
      case 'pending': return 'yellow';
      default: return 'gray';
    }
  }, [project.status]);
  
  return (
    <div className="border rounded p-4">
      <h3 className="font-bold">{project.name}</h3>
      <p className="text-gray-600">{project.description}</p>
      <div className={`text-${statusColor}-600 mt-2`}>
        Status: {project.status}
      </div>
      <div className="mt-4 flex space-x-2">
        <button onClick={handleEdit}>Edit</button>
        <button onClick={handleDelete}>Delete</button>
      </div>
    </div>
  );
});
```

### Virtualization for Long Lists

Use virtualization for long lists to improve performance:

```tsx
import { useVirtualizer } from '@tanstack/react-virtual';
import { useRef } from 'react';

export function VirtualizedList({ items }) {
  const parentRef = useRef(null);
  
  const rowVirtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50, // Estimate row height
    overscan: 5, // Number of items to render outside of view
  });
  
  return (
    <div 
      ref={parentRef} 
      className="h-[500px] overflow-auto border rounded"
    >
      <div
        style={{
          height: `${rowVirtualizer.getTotalSize()}px`,
          width: '100%',
          position: 'relative',
        }}
      >
        {rowVirtualizer.getVirtualItems().map(virtualRow => (
          <div
            key={virtualRow.index}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${virtualRow.size}px`,
              transform: `translateY(${virtualRow.start}px)`,
            }}
          >
            <div className="border-b p-3">
              {items[virtualRow.index].name}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

## Testing Patterns

### Component Testing Strategy

Implement a testing strategy that focuses on user behavior:

```tsx
// Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Button } from '@/components/ui/Button';

describe('Button', () => {
  // Test rendering
  it('renders correctly with default props', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();
  });
  
  // Test user interactions
  it('calls onClick handler when clicked', async () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    await userEvent.click(screen.getByRole('button', { name: /click me/i }));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
  
  // Test accessibility
  it('is accessible via keyboard', async () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    const button = screen.getByRole('button', { name: /click me/i });
    button.focus();
    expect(button).toHaveFocus();
    
    // Simulate pressing Enter
    fireEvent.keyDown(button, { key: 'Enter', code: 'Enter' });
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
  
  // Test variants
  it('applies the correct class for variant', () => {
    const { rerender } = render(<Button variant="solid">Solid</Button>);
    expect(screen.getByRole('button', { name: /solid/i })).toHaveClass('bg-primary-500');
    
    rerender(<Button variant="outline">Outline</Button>);
    expect(screen.getByRole('button', { name: /outline/i })).toHaveClass('border-primary-500');
  });
});
```

## Best Practices

### Composition Over Inheritance

Favor composition over inheritance for sharing functionality:

```tsx
// Instead of inheritance
class BaseInput extends React.Component {
  // Base implementation
}

class TextInput extends BaseInput {
  // Extended implementation
}

// Prefer composition
function Input(props) {
  // Base implementation
  return <input {...props} />;
}

function TextInput(props) {
  return <Input type="text" {...props} />;
}

function PasswordInput(props) {
  return <Input type="password" {...props} />;
}
```

### Progressive Enhancement

Build features with progressive enhancement in mind:

```tsx
// Basic component that works without JavaScript
function ProgressiveForm() {
  return (
    <form action="/api/submit" method="post">
      <label htmlFor="name">Name:</label>
      <input id="name" name="name" required />
      <button type="submit">Submit</button>
    </form>
  );
}

// Enhanced version with client-side validation and submission
function EnhancedForm() {
  const [name, setName] = useState('');
  const [error, setError] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    
    if (!name.trim()) {
      setError('Name is required');
      return;
    }
    
    setIsSubmitting(true);
    
    try {
      const response = await fetch('/api/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name }),
      });
      
      if (!response.ok) throw new Error('Submission failed');
      
      // Handle success
    } catch (err) {
      setError(err.message);
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <form action="/api/submit" method="post" onSubmit={handleSubmit}>
      <label htmlFor="name">Name:</label>
      <input 
        id="name" 
        name="name" 
        value={name} 
        onChange={(e) => setName(e.target.value)} 
        required 
      />
      {error && <div className="text-red-500">{error}</div>}
      <button 
        type="submit" 
        disabled={isSubmitting}
      >
        {isSubmitting ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
}
```

## Conclusion

By following these design patterns and best practices, you'll create Yamify applications that are maintainable, scalable, and adhere to modern web development standards.

These patterns are not rigid rules but rather guidelines that have proven effective in real-world applications. Adapt them to your specific project requirements as needed.

## Related Resources

- [Advanced Usage](/development/advanced-usage)
- [Architecture Overview](/architecture/technologies)
- [Contributing Guidelines](/development/contributing)
- [API Documentation](/api-docs/overview)
